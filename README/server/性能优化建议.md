# 队列系统性能优化建议

## 一、前端性能优化

### 1.1 定时器优化（高优先级）

#### 问题点：
- **CounterView.vue**：
  - 每10秒刷新等待人数（第462行）
  - 每5秒刷新当前票号（第465行）
  - 每10秒刷新上一个服务号（第468行）
  - 每秒更新日期时间（第227行）
  - **问题**：多个定时器未在组件卸载时清理，可能导致内存泄漏

- **DisplayView.vue**：
  - 每5秒轮询刷新数据（第794行）
  - **问题**：已有WebSocket事件监听，轮询是冗余的

#### 优化建议：
1. **合并定时器**：将多个定时器合并为一个，减少定时器数量
2. **清理定时器**：在`onUnmounted`中清理所有定时器
3. **减少轮询**：DisplayView应该主要依赖WebSocket推送，轮询作为兜底机制
4. **日期时间优化**：使用`requestAnimationFrame`或减少更新频率

### 1.2 图片处理优化

#### 问题点：
- **DisplayView.vue**：`extractBackgroundColor`每次组件加载都执行（第651行）
- **问题**：图片处理是异步操作，可能阻塞渲染

#### 优化建议：
1. **缓存背景色**：将提取的背景色缓存到`localStorage`
2. **预加载**：在应用启动时预加载图片
3. **使用CSS变量**：如果背景色固定，直接使用CSS变量

### 1.3 内存管理优化

#### 问题点：
- **DisplayView.vue**：`recentPlayedTickets` Map可能无限增长（第87行）
- **问题**：虽然有清理机制，但在高并发情况下可能不够

#### 优化建议：
1. **限制Map大小**：设置最大条目数，超出时自动清理最旧的
2. **使用LRU缓存**：实现最近最少使用算法
3. **定期清理**：增加清理频率或使用定时清理

### 1.4 API调用优化

#### 问题点：
- **CounterView.vue**：多个独立的API调用（第480-484行）
- **问题**：可以合并为批量接口

#### 优化建议：
1. **批量接口**：创建`/api/counters/:counterNumber/dashboard`接口，一次性返回所有需要的数据
2. **请求去重**：使用防抖/节流避免重复请求
3. **请求合并**：使用`Promise.all`并行请求（已实现，但可以进一步优化）

## 二、后端性能优化

### 2.1 数据库查询优化（高优先级）

#### 问题点：
- **businessTypeController.js**：`getBusinessTypesWithLatestTickets`执行两次查询（第66-109行）
  - 第一次：执行复杂SQL查询
  - 第二次：`findAll`查询所有业务类型
- **问题**：可以合并为一次查询

#### 优化建议：
1. **合并查询**：修改SQL查询，直接包含所有业务类型（即使没有服务记录）
2. **添加索引**：
   - `ticket_sequences(business_type_id, date)` - 复合索引
   - `counter_business_last_ticket(business_type_id, counter_id)` - 复合索引
   - `counters(counter_number)` - 单列索引
   - `settings(key)` - 单列索引（如果还没有）

### 2.2 WebSocket优化（中优先级）

#### 问题点：
- **websocket/index.js**：所有事件都广播给所有客户端（第39、52、59行）
- **问题**：不需要所有客户端都接收所有事件

#### 优化建议：
1. **房间机制**：使用Socket.IO的房间功能
   - 显示屏客户端加入`display`房间
   - 柜台客户端加入`counter:${counterNumber}`房间
   - 按业务类型分组：`business:${businessTypeId}`
2. **选择性广播**：只向相关房间发送事件
3. **减少广播频率**：合并多个小事件为一个大事件

### 2.3 API响应优化

#### 问题点：
- **多个设置查询**：DisplayView需要多次调用获取设置（第115-144行）
- **问题**：可以合并为一个接口

#### 优化建议：
1. **批量设置接口**：创建`/api/settings/batch?keys=voice_volume,voice_rate,display_remarks`
2. **缓存设置**：在服务器端缓存设置值，减少数据库查询
3. **使用Redis**：如果部署多实例，使用Redis缓存

## 三、具体优化实施建议

### 3.1 立即实施（高优先级）

1. **修复定时器内存泄漏**
   ```javascript
   // CounterView.vue
   onUnmounted(() => {
     // 清理所有定时器
     if (waitingCountsInterval) clearInterval(waitingCountsInterval);
     if (currentTicketInterval) clearInterval(currentTicketInterval);
     if (lastServiceInterval) clearInterval(lastServiceInterval);
     if (dateTimeInterval) clearInterval(dateTimeInterval);
     if (toastTimer) clearTimeout(toastTimer);
   });
   ```

2. **优化数据库查询**
   - 合并`getBusinessTypesWithLatestTickets`的两次查询
   - 添加必要的数据库索引

3. **减少轮询频率**
   - DisplayView的轮询间隔改为10-15秒
   - 主要依赖WebSocket推送

### 3.2 中期优化（中优先级）

1. **实现WebSocket房间机制**
2. **创建批量API接口**
3. **实现设置缓存**

### 3.3 长期优化（低优先级）

1. **使用Redis缓存**
2. **实现请求防抖/节流**
3. **添加性能监控**

## 四、性能监控建议

### 4.1 前端监控
- 使用`Performance API`监控页面加载时间
- 监控定时器执行频率
- 监控内存使用情况

### 4.2 后端监控
- 监控数据库查询时间
- 监控WebSocket连接数
- 监控API响应时间

## 五、预期效果

实施这些优化后，预期可以获得：
- **前端性能提升30-50%**：减少不必要的轮询和API调用
- **后端性能提升20-40%**：优化数据库查询，减少查询次数
- **内存使用降低**：修复内存泄漏，优化缓存策略
- **用户体验改善**：更快的响应速度，更流畅的交互

## 六、注意事项

1. **渐进式优化**：不要一次性实施所有优化，逐步实施并测试
2. **保持兼容性**：确保优化不影响现有功能
3. **测试覆盖**：每次优化后都要进行充分测试
4. **监控影响**：实施优化后监控系统性能，确保达到预期效果

